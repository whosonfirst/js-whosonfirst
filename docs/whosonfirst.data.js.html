<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: whosonfirst.data.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: whosonfirst.data.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @namespace whosonfirst.data
 * @description Methods for retrieving Who's On First data records.
 */

var whosonfirst = whosonfirst || {};

whosonfirst.data = (function(){
	
    var default_cache_ttl = 30000; // ms
    
    var self = {

	/**
	 * @typedef {Object} fetchWithEndpointsResult
	 * @memberof whosonfirst.data	   	   
	 * @property {Object} data - The body of the Who's On First GeoJSON Feature record that was retrived.
	 * @property {string} endpoint â€“ The endpoint from which the Who's On First GeoJSON Feature record was retrieved.
	 */

	/**
	 * @typedef {Object} fetchArgs
	 * @memberof whosonfirst.data	   	   
	 * @property {number} cache_ttl - The "time to live" in milliseconds for cached items. Optional, default is 30000.
	 * @property {boolean} cache-busting - If true then all URLs will be appended with a '?cb={random_number}' query parameter.
	 */
	   
	/**
	 * @function fetchWithEndpoints
	 * @memberof whosonfirst.data	   
	 * @description Fetch the body of a Who's On First GeoJSON Feature record from a set of endpoints, returning data
	 * for the first successful response..
	 * @param {string[]} endpoints - A list of endpoints to query.
	 * @param {number} rel_path - The relative path of the Who's On First document to fetch.
	 * @params {fetchArgs} args - Optionals arguments for fetching records.
	 * @returns {Promise.&lt;fetchWithEndpointsResult>} A fetchWithEndpointsResult object.
	 */
	fetchWithEndpoints: function(endpoints, rel_path, args) {

	    return new Promise((resolve, reject) => {

		(async () => {
		    const count = endpoints.length;
		    
		    for (var i=0; i &lt; count; i++){

			const endpoint = endpoints[i];
			const uri = endpoint + rel_path;
			console.debug("Fetch with endpoint", endpoint, rel_path);
			
			try {
			    const rsp = await self.fetch(uri, args);
			    resolve({"data": rsp, "endpoint": endpoint});
			    return;
			} catch (err) {
			    console.error("Failed to fetch", uri, err);
			}
		    }
		    
		    reject(new Error('All fetch attempts failed'));
		})();
		
	    });
	},

	/**
	 * @function fetch
	 * @memberof whosonfirst.data
	 * @description Fetch the body of a Who's On First GeoJSON Feature record.
	 * @param {string} uri - The absolute URI of the Who's On First document to fetch.
	 * @params {fetchArgs} args - Optionals arguments for fetching records.
	 * @returns {Promise.&lt;Object>} The body the Who's On First GeoJSON Feature record.
	 */	
	fetch: function(url, args){
	    
	    return new Promise((resolve, reject) => {
		
		if (typeof(args) == "undefined") {
		    args = {};
		}
		
		else if (typeof(args) == "number") {
		    args = { "cache_ttl": args };
		}
		
		else {}
		
		if (args["cache_ttl"]){
		    var cache_ttl = args["cache_ttl"];
		}
		
		else {
		    var cache_ttl = default_cache_ttl;
		}
		
		self.cache_get(url, cache_ttl).then ((data) => {
		    resolve(data);
		}).catch((err) => {
		    console.debug("Failed to retrieve cache data", url, err);

		    if (args["cache-busting"]){
			
			var cb = Math.floor(Math.random() * 1000000);
			
			var tmp = document.createElement("a");
			tmp.href = url;
			
			if (tmp.search){
			    tmp.search += "&amp;cb=" + cb;
			}
			
			else {
			    tmp.search = "?cb= " + cb;
			}
			
			url = tmp.href;
		    }
		    
		    fetch(url).then(rsp =>
			rsp.json()
		    ).then((data) => {
			
			self.cache_set(url, data).catch((err) => {
			    console.error("Failed to cache URL", url, err);
			});
			
			resolve(data);
			
		    }).catch((err) => {
			console.error("Failed to fetch URI", url, err)
			reject(err);
		    });
			
		});
	    });

	},

	/**
	 * Fetch the body of a Who's On First GeoJSON Feature record from the local cache.
	 *
	 * @param {string} key - The cache key the Who's On First document to fetch.
	 * @param {number} ttl - The maximum age (in seconds) for cache items to be considered valid.
	 * @returns {Promise.&lt;Object>} The body the Who's On First GeoJSON Feature record.
	 */		
	cache_get: function(key, cache_ttl){
	    
	    return new Promise((resolve, reject) => {
		
		if (typeof(localforage) != 'object'){
		    reject("Missing local forage");
		    return;
		}
		
		var fq_key = self.cache_prep_key(key);
		
		localforage.getItem(fq_key, function (err, rsp){
		    
		    if ((err) || (! rsp)){
			reject(err);
			return;
		    }
		    
		    var data = rsp['data'];
		    
		    if (! data){
			reject();
			return;
		    }
		    
		    var dt = new Date();
		    var ts = dt.getTime();
		    
		    var then = rsp['created'];
		    var diff = ts - then;
		    
		    if (diff > cache_ttl){
			self.cache_unset(key).catch((err) => {
			    console.error("Failed to set cache key", key, err)
			});
			reject();
			return;
		    }
		    
		    resolve(data);
		});
	    });
	    
	},

	/**
	 * Cache the body of a Who's On First GeoJSON Feature record locally.
	 *
	 * @param {string} key - The cache key the Who's On First document to cache.
	 * @param {Object} value - The body the Who's On First GeoJSON Feature record to cache.
	 * @returns {Promise} 
	 */		
	cache_set: function(key, value){
	    
	    return new Promise((resolve, reject) => {
		
		if (typeof(localforage) != 'object'){
		    reject("Missing localforage");
		    return;
		}
		
		var dt = new Date();
		var ts = dt.getTime();
		
		var wrapper = {
		    'data': value,
		    'created': ts
		};
		
		key = self.cache_prep_key(key);
		
		localforage.setItem(key, wrapper);
		resolve();
	    });
	    
	},

	/**
	 * Remove a Who's On First GeoJSON Feature record from the local cache.
	 *
	 * @param {string} key - The cache key the Who's On First document to remove.
	 * @returns {Promise} 
	 */			
	cache_unset: function(key){
	    
	    return new Promise((resolve, reject) => {
		
		if (typeof(localforage) != 'object'){
		    reject("Missing localforage");
		    return;
		}
		
		key = self.cache_prep_key(key);
		
		localforage.removeItem(key);
		resolve();
	    });
	    
	},

	/**
	 * @access private
	 * @description Internal helper to append a local identifier to cache keys.
	 */
	'cache_prep_key': function(key){
	    return key + '#whosonfirst.data';
	},
	
    };
    
    return self;

})();
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="whosonfirst.html">whosonfirst</a></li><li><a href="whosonfirst.data.html">data</a></li><li><a href="whosonfirst.flags.html">flags</a></li><li><a href="whosonfirst.flags.existential.html">existential</a></li><li><a href="whosonfirst.geojson.html">geojson</a></li><li><a href="whosonfirst.namify.html">namify</a></li><li><a href="whosonfirst.placetypes.html">placetypes</a></li><li><a href="whosonfirst.uri.html">uri</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Fri Aug 22 2025 15:33:10 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
